# Producer
Bueno vamos a crear un producer con memoria compartida limitada, para eso vamos a crear un struct como se muestra en la guia del laboratorio el cual este nos ayudara a limitar la memoria con el tamaño que le daremos a este struct, luego se realiza las funciones que se enseño en el laboratorio para poder crear una memoria separada con shm_open() pueden separar memoria y con mmap() se puede mapear esa memoria de lo mas bajo hasta el tope de esta, el struct que utilizaremos sera un arreglo de este osea un arreglo de region(); el cual este vendria a almacenar cada espacio de memoria con los datos que le mandaremos en este caso el pid y la hora de cracion, luego se crean variables para la condicion de llenado de memoria y otra con la generacion de la hora, por ejemplo con next_producer es en el cual vamos a almacenar la hora y el pid del hijo del padre general, el cual despues con nemcpy() vamos a almacenar en la memoria compartida mediante y como struct region rpt es un arreglo este se comportara como buffer en el cual cada hijo creado va almacenar sus datos, el programa de producer.c imprime la hora y el pid padre y pid hijo cada vez q se crea un hijo

# Consumer

En esta parte vamos a crear un consumer el cual va a eliminar cada proceso creado por el consumer.c esto primero como siempre debemos crear un struct del mismo tamaño que el struct de producer.c el cual vamos a asignar la memoria con shm_open() en modo de lectura y despues el mapeo con mmap(), con otro arreglo rptr, tambien para saber cuanto tiempo va a estar vivo un hijo vamos a crear la funcion ttestimado y particion para sacar la diferencia de tiempos en el de creacion hasta su muerte, luego tambien realizaremos un struct region next_consumer, el cual utilizando los ejemplos en la guai de laboratorio dependiendo ciertas condiciones en nuestro main va a sacar del buffer compartido en producer y dependiendo si esta vacio o lleno tambien va a leerlo y matar el proceso

# Comentarios

Este laboratorio es corregido de uno anterior el cual al principio a pesar de compartir la memoria el producer y el consumer el consumer realizaba una violacion de segmentacion de memoria el cual se arreglo pero habia un problema el arreglo de struct region (buffer) es muy necesario, ya que al realizarlo por primera vez solo utizando un struct se puede desarrollar la destruccion de procesos, pero esto se debe hacer con una espera o sleep muy precisos osea que no cumpliriamos con el laboratorio de utilizar un sleep(random), ya que al no matar el proceso a tiempo va a separarse del padre y sera un hijo huerfano o tambien se debe mandar kill() cada vez q veamos que el producer.c mande un nuevo nodo, en cambio al almacenar en un buffer podemos almacenarlo a cada rato y eliminarlo sin preocuparse de la perdida de nodos y no eliminacion a tiempo de estos